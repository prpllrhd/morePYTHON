#    Copyright (C) 2012 Yahoo! Inc. All Rights Reserved.
"""
Yahoo backyard authentication handler
"""
from __future__ import absolute_import, print_function
from future import standard_library
standard_library.install_aliases()
from builtins import str
from builtins import object

__import__('pkg_resources').declare_namespace(__name__)

import base64
from datetime import datetime
from datetime import timedelta
import errno
import os
import re
from io import BytesIO as StringIO
import urllib.request, urllib.parse, urllib.error

from Crypto.Hash import MD5
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5
from IPy import IP

from . import exceptions


# where to go to login and get BY/GH cookie
GUESTHOUSE_SSO_URI = "https://gh.bouncer.login.yahoo.com/login/"
BACKYARD_SSO_URI = "https://by.bouncer.login.yahoo.com/login/"

# path to file containing key used for signature validation
# file comes from package bycookieauthkey during screwdriver build
# during package install, it is placed using data_files of setup.py
PUB_KEY_FN = os.path.join(os.path.dirname(__file__), 'conf/myby.pub')
PUB_KEY_KEY = 'bouncer.cookie.yby.pub'

# If roles has this, then this is alternative signature
SIGN2_SEARCH = "|sign2."

# Default max expiry of 600 minutes
DEF_MAX_EXPIRE = timedelta(minutes=600)


def get_ysecure_key(keyname='bouncer.cookie.yby.pub', version=0):
    result = os.popen(
        '/home/y/bin/ykeykeygetkey -v %d %s' % (version, keyname)
    ).read().strip()
    return result


def _y64_2_b64(s):
    return s.translate(str.maketrans('-._', '=+/'))


class BYCookie(object):
    def __init__(self, text, timeout=DEF_MAX_EXPIRE,
                 key_filename=PUB_KEY_FN, ykeykey_keyname=PUB_KEY_KEY):
        self.raw = str(text)
        self.unquoted = urllib.parse.unquote(self.raw)
        self.fields = urllib.parse.parse_qs(self.unquoted)
        self.timeout = timeout
        if not self.fields:
            self.fields = {}
        self.key_filename = key_filename
        self.ykeykey_keyname = ykeykey_keyname

    def __str__(self):
        return self.raw

    def _take_first(self, key):
        try:
            value = self.fields[key]
        except KeyError as e:
            raise exceptions.BYFieldException("Missing field: %s" % e)
        if isinstance(value, (list, tuple)):
            try:
                value = value[0]
            except IndexError as e:
                raise exceptions.BYFieldException("Missing field: %s" % e)
        return value

    @property
    def userid(self):
        """
        Get the userid from the by cookie

        Returns
        -------
        str
            Backyard user id
        """

        return self._take_first('userid')

    @property
    def time(self):
        """
        Get the time from the backyard cookie

        Returns
        -------
        datetime.datetime - Timestamp from cookie in UTC
        """
        time = self._take_first('time')
        return datetime.utcfromtimestamp(int(time))

    @property
    def kvr(self):
        """
        Get the RSA ykeykey version from the cookie

        Returns
        -------
        int
            Version of the RSA key to use from ykeykey or 0 if there is no
            key version specified.
        """
        for role in self.role_list:
            if role.startswith('kvr.'):
                return int(role.replace('kvr.', ''))
        return 0

    @property
    def kve(self):
        """
        Get the ECDSA ykeykey version from the cookie

        Returns
        -------
        int
            Version of the DSA key to use from ykeykey or 0 if there is no
            key version specified.
        """
        for role in self.role_list:
            if role.startswith('kve.'):
                return int(role.replace('kve.', ''))
        return 0

    def _get_rsa(self):
        raw_key = None
        if self.ykeykey_keyname:
            raw_key = get_ysecure_key(self.ykeykey_keyname, self.kvr)
        if not raw_key and self.key_filename:
            try:
                with open(self.key_filename, 'rb') as fh:
                    raw_key = fh.read()
            except IOError as e:
                if e.errno != errno.ENOENT:
                    raise
        if not raw_key:
            raise IOError("Could not get any valid RSA public key")
        return RSA.importKey(raw_key)

    def _try_validate_signature(self):
        # And now try sign
        return self._validate_signature(self.roles, self.signature())

    def _validate_signature(self, roles, signature):
        public_key = self._get_rsa()
        pkt = StringIO()
        pkt.write(roles.encode('utf-8'))
        # These fields (in the raw form) seem to be what composes the message
        for f in ['userid', 'time', 'expires', 'ip']:
            pkt.write(str(self._take_first(f)).encode('utf-8'))

        verifier = PKCS1_v1_5.new(public_key)
        h = MD5.new(pkt.getvalue())
        status = verifier.verify(h, signature)
        return status

    def _validate_ip(self, remote_ip):
        if not remote_ip:
            return True
        remote_ip = IP(str(remote_ip))
        try:
            if remote_ip == self.ip:
                return True
        except (ValueError, TypeError, KeyError):
            pass
        try:
            if remote_ip == self.ip2:
                return True
        except (ValueError, TypeError, KeyError):
            pass
        try:
            if remote_ip == self.ip3:
                return True
        except (ValueError, TypeError, KeyError):
            pass
        return False

    def validate(
            self, validate_signature=False, check_expires=True, remote_ip=None):
        # Ensure certain fields exist by accessing them...
        if not all([self.userid, self.id, self.time, self.ip]):
            raise exceptions.BYFieldException("Missing required fields")
        if check_expires and (self.expires_on < datetime.utcnow()):
            raise exceptions.BYExpiredException(
                'Cookie expired @ %s' % (self.expires_on))
        if not self._validate_ip(remote_ip):
            ips = [str(f) for f in self.ips if f]
            if not ips:
                ips = ['??']
            msg = 'Remote IP %s does not match %s' % (
                remote_ip, " or ".join(ips))
            raise exceptions.BYBadIPException(msg)
        if validate_signature and not self._try_validate_signature():
            raise exceptions.BYBadSignatureException(
                "Cookie signature invalid!")

    def signature(self, decode=True):
        normal_b64 = _y64_2_b64(self._take_first('sign'))
        if decode:
            return base64.b64decode(normal_b64)
        else:
            return normal_b64

    def signature2(self, decode=True):
        roles_text = self._take_first('roles')
        sign2_loc = roles_text.find(SIGN2_SEARCH)
        if sign2_loc == -1:
            return ''
        sign2 = roles_text[sign2_loc + len(SIGN2_SEARCH):]
        if len(sign2) == 0 or sign2 == '|':
            return ''
        normal_b64 = sign2.split("|")[0]
        if decode:
            return base64.b64decode(normal_b64)
        else:
            return normal_b64

    @property
    def roles2(self):
        roles_text = self._take_first('roles')
        sign2_loc = roles_text.find(SIGN2_SEARCH)
        if sign2_loc == -1:
            return ''
        sign2 = roles_text[sign2_loc + len(SIGN2_SEARCH):]
        if len(sign2) == 0 or sign2 == '|':
            return ''
        next_role = sign2.find("|")
        if next_role == -1:
            return ''
        sign2 = sign2[next_role:]
        if sign2 == "0|":
            return '0'
        return sign2

    @property
    def ip(self):
        return IP(str(self._take_first('ip')))

    @property
    def ip2(self):
        roles = self._parse_roles(self.roles)
        return IP(str(roles['ip2'].strip()))

    @property
    def ip3(self):
        roles = self._parse_roles(self.roles)
        return IP(str(roles['ip3'].strip()))

    @property
    def id(self):
        return self._take_first('id')

    @property
    def ips(self):
        ips = []
        try:
            ips.append(self.ip)
        except (ValueError, KeyError):
            ips.append(None)
        try:
            ips.append(self.ip2)
        except (ValueError, KeyError):
            ips.append(None)
        try:
            ips.append(self.ip3)
        except (ValueError, KeyError):
            ips.append(None)
        return ips

    @property
    def expires_on(self):
        expire_minutes = self._take_first('expires')
        expire_minutes = max(0, int(expire_minutes))  # Clamp in positive time
        expire_delta = timedelta(minutes=expire_minutes)
        use_delta = self.timeout
        if expire_delta < use_delta:
            use_delta = expire_delta
        created_on = self.time
        return created_on + expire_delta

    def _parse_roles(self, roles_text):
        # Remove subroles
        # TODO(harlowja): find out what these are for...
        roles_text = re.sub(r"\[(.*?)\]", "", roles_text)
        roles = roles_text.split("|")
        real_roles = {}
        for r in roles:
            if not len(r):
                continue
            idx = r.find(".")
            if idx >= 0:
                before = r[0:idx].strip()
                after = r[idx + 1:].strip()
                if len(before):
                    real_roles[before] = after
        return real_roles

    @property
    def role_list(self):
        return self.roles.split('|')

    @property
    def roles(self):
        return self._take_first('roles')


# putting this at the end since it needs the above things to be there already
from .backyard import *
from .BackyardAuth import BackyardAuth
