"""
Bouncer authentication handler for urllib2 and requests.
This can also be used to simply get Bouncer cookies.
"""
from future import standard_library
standard_library.install_aliases()
from builtins import str
from builtins import object
import http.cookiejar
import getpass
import urllib.request, urllib.error, urllib.parse
import warnings

# if urllib2 is there, installSSO should patch it
urllib2_supported = False
try:
    import urllib2
    urllib2_supported = True
except ImportError:
    pass

import requests

from yahoo.backyard import auth as bouncer_auth
from yahoo.backyard import BACKYARD_SSO_URI
from yahoo.backyard import GUESTHOUSE_SSO_URI


# redirect_reason in response URL which should prompt reauthentication attempt
# because they likely mean cookie timing out or missing or not valid
_COOKIE_MISSING = "YBY_MISSING"  # redirect_reason when no cookie
_COOKIE_TIMEOUT = "YBY_TIMEOUT"  # redirect_reason when BY cookie timed out
_IP_MISMATCH = "YBY_IP_MISMATCH"  # redirect_reason when IP mismatch

# HTTP error codes related to redirect issues
_REDIRECT_CODES = (301, 302, 303, 307)

# preserve access to the original methods that we patch in installSSO()
# needed for requests patching and allows to un-installSSO()
_url_urlopen = urllib.request.urlopen
_url2_urlopen = None
if urllib2_supported:
    _url2_urlopen = urllib2.urlopen
_req_get = requests.get
_req_options = requests.options
_req_head = requests.head
_req_post = requests.post
_req_put = requests.put
_req_patch = requests.patch
_req_delete = requests.delete


def get_cookie(user=None, password=None, auth_uri=None):
    """Gets BY cookie and returns it as string."""
    # if auth_uri not specified, use our own
    if not auth_uri:
        auth_uri = BACKYARD_SSO_URI
    if not user or not password:
        user, password = SingleSignOn(user=user, password=password)

    by_ck = bouncer_auth.get_validate_yby_cookie_from_bouncer(user, password,
                                                              by_url=auth_uri)

    return str(by_ck)


def get_cookie_dict(auth_uri=None, user=None, password=None):
    """Returns the BY cookie as a dict.

    This exists for backwards compatibility and for more convenient attaching
    of cookie to requests calls.
    """
    if not user or not password:
        user, password = SingleSignOn(user=user, password=password)

    by_ck = get_cookie(user=user, password=password, auth_uri=auth_uri)
    return {"YBY": by_ck}


def _bad_resp_url(resp_url):
    """Returns True if resp_url's redirect_reason indicates a Bouncer issue."""
    try:
        reason = urllib.parse.parse_qs(resp_url)['redirect_reason']
        if reason in (_COOKIE_MISSING, _COOKIE_TIMEOUT, _IP_MISMATCH):
            return True
        else:
            return False

    except KeyError:  # no redirect_reason
        return False


class BouncerAuthUrllib2(object):

    def __init__(self, user, password, auth_uri):
        self.user = user
        self.password = password
        self.auth_uri = auth_uri
        # save last good cookie so we don't have to get new one each time
        self.last_good_ck = None

    def _update_opener_cookie(self, opener, last_by_ck=None, auth_uri=None):
        """Remove existing cookie last_by_ck from opener headers if it's there.

        Add last_good_ck or new cookie from auth_uri to opener.
        """
        if last_by_ck:  # we must be retrying after failure if we have last ck
            opener.addheaders.remove(("Cookie", "YBY=" + last_by_ck))

        by_ck = None
        if self.last_good_ck:
            by_ck = self.last_good_ck

        if not by_ck:
            by_ck = get_cookie(user=self.user,
                               password=self.password, auth_uri=auth_uri)

        opener.addheaders.append(("Cookie", "YBY=" + by_ck))

        return opener, by_ck

    def _try_open(self, opener, url, data, **openparams):
        resp = None
        try:
            resp = opener.open(url, data, **openparams)
            # if final url indicates a problem,
            if _bad_resp_url(resp.geturl()):
                return False
        except urllib.error.HTTPError as err:
            # having wrong cookie (BY instead of GHouse) causes a redirect loop
            # so we return False to try another cookie
            if err.code in _REDIRECT_CODES:
                return False
            else:
                raise

        return resp

    def _attempt_open(self, opener, url, data, auth_uri=None, last_ck=None,
                      **openparams):
        """Set cookies and make the request.

        Also, set last_good_ck based on resp.
        """
        # add a cookie to our opener
        opener, last_by_ck = self._update_opener_cookie(opener,
                                                        last_by_ck=last_ck,
                                                        auth_uri=auth_uri)
        # try opening the url with the opener
        # resp will be False if there's a problem
        resp = self._try_open(opener, url, data, **openparams)

        if not resp:
            # we no longer have a last good cookie since we failed
            self.last_good_ck = None
        else:  # save this cookie since it worked
            self.last_good_ck = last_by_ck

        return resp, last_by_ck

    def urlopen(self, url, data=None, **openparams):
        """Does what urllib2.urlopen does, but with a BY cookie.

        Additionally, performs re-auth and re-try when a cookie no longer
        works.
        Also tries to auth with Guesthouse URI and BY URI.
        """
        # handler is passed in during testing to get headers we are sending
        if 'handler' in openparams:
            opener = urllib.request.build_opener(openparams['handler'])
            del openparams['handler']
        else:
            opener = urllib.request.build_opener()

        # initial cookie used is from the user-provided auth_uri
        resp, last_ck = self._attempt_open(opener, url, data,
                                           auth_uri=self.auth_uri,
                                           **openparams)

        # if resp is not True, there was a problem,
        # try to get new cookie from Guesthouse uri and then try open again
        if not resp:
            resp, last_ck = self._attempt_open(opener, url, data,
                                               auth_uri=GUESTHOUSE_SSO_URI,
                                               last_ck=last_ck, **openparams)

            # if resp is not True, there was a problem,
            # try to re-auth with BY uri this time and try open again
            if not resp:
                resp, _ = self._attempt_open(opener, url, data,
                                             last_ck=last_ck, **openparams)

                if not resp:
                    raise urllib.error.HTTPError("Failed to access page after "
                                            "trying BY and GH URIs.")
                else:  # no problem after authing with gh uri, return response
                    return resp

            else:  # no problem after authing with by uri, return response
                return resp

        else:  # no problem, return response
            return resp


class BouncerAuthRequests(object):

    def __init__(self, user, password, auth_uri):
        self.user = user
        self.password = password
        self.auth_uri = auth_uri
        # save last good cookie so we don't have to get new one each time
        self.last_good_ck = None

    def _update_cookie(self, kwargs, auth_uri=None):
        """Update kwargs to have appropriate cookie dict/jar.

        Either last_good_ck or new cookie from auth_uri is added.
        If user provided a cookies dict or jar, YBY cookie is merged in.
        """
        by_ck = None
        if self.last_good_ck:
            by_ck = self.last_good_ck

        if not by_ck:
            by_ck = get_cookie(user=self.user,
                               password=self.password, auth_uri=auth_uri)

        # add / merge in the YBY cookie
        try:
            # user passed in a cookie dict, add YBY cookie
            if isinstance(kwargs["cookies"], dict):
                kwargs["cookies"]["YBY"] = by_ck
            # user passed in CookieJar (either cookielib or requests jar)
            elif isinstance(kwargs["cookies"], http.cookiejar.CookieJar):
                # create a cookielib.Cookie of by_ck we got, add it to jar
                # Cookie(version, name, value, port, port_specified, domain,
                # domain_specified, domain_initial_dot, path, path_specified,
                # secure, expires, discard, comment, comment_url, rest,rfc2109)
                ck = http.cookiejar.Cookie(0, "YBY", by_ck, None, False, "", False,
                                      False, "/", True, False, None, True,
                                      None, None, None, False)
                kwargs["cookies"].set_cookie(ck)
            else:
                raise requests.exceptions.RequestException("Unexpected cookies"
                                                           " container.")
        except KeyError:  # user didn't pass in cookies at all
            kwargs["cookies"] = {"YBY": by_ck}

        return kwargs, by_ck

    def _try_requests_method(self, requests_method, url, **kwargs):
        r = None
        try:
            r = requests_method(url, **kwargs)
            if _bad_resp_url(r.url):
                return False
        # TooManyRedirects if wrong cookie is used (like BY instead of GH)
        except requests.exceptions.TooManyRedirects:
            return False  # we must have the wrong cookie

        return r

    def _attempt_request(self, requests_method, url, auth_uri=None, **kwargs):
        """Set cookies and make the request.

        Also set last_good_ck based on resp.
        """
        kwargs, by_ck = self._update_cookie(kwargs, auth_uri=auth_uri)
        r = self._try_requests_method(requests_method, url, **kwargs)

        if not r:
            # we no longer have a last good cookie since we failed
            self.last_good_ck = None
        else:  # save this cookie since it worked
            self.last_good_ck = by_ck

        return r

    def _requests_wrap(self, requests_method, url, **kwargs):
        """Wraps around the supplied requests_method method to supply cookies.

        Additionally, re-auths and re-tries when cookies don't work.
        Also tries to auth with Guesthouse URI if no success with cookies from
        authing with BY URI.
        """
        # initial cookie used is from the user-provided auth_uri
        r = self._attempt_request(requests_method, url,
                                  auth_uri=self.auth_uri, **kwargs)

        # if r is not True, there is a problem; try cookie from GH Bouncer
        if not r:
            r = self._attempt_request(requests_method, url,
                                      auth_uri=GUESTHOUSE_SSO_URI, **kwargs)

            # if r still not True, try again with BY cookie
            if not r:
                r = self._attempt_request(requests_method, url, **kwargs)

                # if cookie from BY didn't work, give up
                if not r:
                    err_msg = ("Failed to access page after trying BY and "
                               "GH URIs.")
                    raise requests.exceptions.RequestException(err_msg)

                else:  # no problem after using BY cookie
                    return r
            else:  # no problem after retrying with GH cookie
                return r
        else:  # no problem, return result
            return r

    def get(self, url, **kwargs):
        return self._requests_wrap(_req_get, url, **kwargs)

    def options(self, url, **kwargs):
        return self._requests_wrap(_req_options, url, **kwargs)

    def head(self, url, **kwargs):
        return self._requests_wrap(_req_head, url, **kwargs)

    def post(self, url, data=None, **kwargs):
        return self._requests_wrap(_req_post, url, data=data, **kwargs)

    def put(self, url, data=None, **kwargs):
        return self._requests_wrap(_req_put, url, data=data, **kwargs)

    def patch(self, url, data=None, **kwargs):
        return self._requests_wrap(_req_patch, url, data=data, **kwargs)

    def delete(self, url, **kwargs):
        return self._requests_wrap(_req_delete, url, **kwargs)


def SingleSignOn(user=None, password=None):
    """This method is called SingleSignOn for backwards compatibility.

    It gets user credentials that we will use.
    """
    if not user:
        user = getpass.getuser()
    if not password:
        password = getpass.getpass(prompt="Enter Bouncer password for "
                                          "(" + user + "): ")

    return user, password


def installSSO(sso=None, user=None, password=None, auth_uri=None):
    """Set credentials, patch urllib2 and requests functionality.

    Parameter 'sso' is only here for backwards compatibilty with old backyard
    module versions.
    Not thread safe!
    """
    warning_msg = ("The patching done by installSSO() is not thread safe. "
                   "Please consider using requests with BackyardAuth "
                   "authentication handler instead. Consult the README to "
                   "learn more about this warning and/or how to disable it.")
    warnings.warn(warning_msg, RuntimeWarning)

    # With the very old backyard module, users would do
    # sso = yahoo.backyard.SingleSignOn(user='xxx', password='xxx')
    # yahoo.backyard.installSSO(sso=sso)
    # this 'if-else' makes sure that such old usage still works
    # since SingleSignOn returns user, password now
    if sso:
        user, password = sso
    else:
        user, password = SingleSignOn(user, password)

    # patch urllib2.urlopen
    bouncer_urllib2 = BouncerAuthUrllib2(user, password, auth_uri)
    urllib.request.urlopen = bouncer_urllib2.urlopen
    setattr(urllib.request, '__sso_installed', True)
    if urllib2_supported:
        urllib2.urlopen = bouncer_urllib2.urlopen
        setattr(urllib2, '__sso_installed', True)

    # patch requests
    bouncer_requests = BouncerAuthRequests(user, password, auth_uri)
    requests.get = bouncer_requests.get
    requests.options = bouncer_requests.options
    requests.head = bouncer_requests.head
    requests.post = bouncer_requests.post
    requests.put = bouncer_requests.put
    requests.patch = bouncer_requests.patch
    requests.delete = bouncer_requests.delete
    setattr(requests, '__sso_installed', True)


def uninstallSSO():
    """Undo patching that is done by installSSO(), if patching was done."""
    if hasattr(urllib.request, "__sso_installed") and urllib.request.__sso_installed:
        urllib.request.urlopen = _url_urlopen
        setattr(urllib.request, '__sso_installed', False)

    if urllib2_supported:
        if hasattr(urllib2, "__sso_installed") and urllib2.__sso_installed:
            urllib2.urlopen = _url2_urlopen
            setattr(urllib2, '__sso_installed', False)

    if hasattr(requests, "__sso_installed") and requests.__sso_installed:
        requests.get = _req_get
        requests.options = _req_options
        requests.head = _req_head
        requests.post = _req_post
        requests.put = _req_put
        requests.patch = _req_patch
        requests.delete = _req_delete
        setattr(requests, '__sso_installed', False)
